// go build -gcflags -m sample.go　でヒープ, スタックのどちらに確保されているかが分かる

// 関数のスコープよりも変数の寿命が長くなるとヒープに逃すようになっている
// (e.g. 関数の引数にポインタで渡す, 関数の返り値にポインタを指定する)
// それ以外も、fmt.Println()のような出力しか行わない関数であっても、ヒープに逃すようになる

// # command-line-arguments
// ./sample.go:28:13: inlining call to fmt.Println
// ./sample.go:14:21: new(Struct) does not escape
// ./sample.go:18:18: &Struct{...} escapes to heap
// ./sample.go:21:11: make([]int, 4) escapes to heap
// ./sample.go:22:11: make([]int, 4, 16) escapes to heap
// ./sample.go:23:11: make(map[string]int) escapes to heap
// ./sample.go:24:11: make(map[string]int, 100) escapes to heap
// ./sample.go:28:13: a escapes to heap
// ./sample.go:28:13: c escapes to heap
// ./sample.go:28:13: e escapes to heap
// ./sample.go:28:13: f escapes to heap
// ./sample.go:28:13: g escapes to heap
// ./sample.go:28:13: []interface {}{...} does not escape
// <autogenerated>:1: .this does not escape

package main

import "fmt"

type Struct struct {
	foo string
}

func main() {
	var a int = 10

	var b *Struct = new(Struct)
	b.foo = "yeah"

	var c Struct = Struct{"Params"}
	var d *Struct = &Struct{"Params"}

	e := [4]int{1, 2, 3, 4}
	f := make([]int, 4)
	g := make([]int, 4, 16)
	h := make(map[string]int)
	i := make(map[string]int, 100)
	j := make(chan string)
	k := make(chan string, 10)

	fmt.Println(a, c, d, e, f, g, h, i, j, k)
}
